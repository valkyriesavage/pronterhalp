<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - multiple views</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
		</style>
		<link rel="stylesheet" type="text/css" href="css/NewHistogram.css">
        <link rel="stylesheet" type="text/css" href="css/3DModel.css">
		<script src="js/three.js"></script>
		<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
		<script src="js/detector.js"></script>
		<script src="js/NewHistogram.js"></script>
	</head>
	<body>
		<script>
			// Histogram #1
            width = window.innerWidth/3;
            height = window.innerHeight/3;
            var h1 = new NewHistogram(width, height, "data/barchart.tsv");
            h1.addToBody();

            // Histogram #2
            var h2 = new NewHistogram(width, height);
            h2.addToBody();

            // Histogram #3
            var h3 = new NewHistogram(width, height);
            h3.addToBody();

			// Returns Sphere with position <x,y,z>
			function makeSphereWithPosition(x,y,z,r) {
				console.log("Radius: " + r);
				// this material causes a mesh to use colors assigned to faces
			    var faceColorMaterial = new THREE.MeshBasicMaterial( 
			    { color: 0xffffff, vertexColors: THREE.FaceColors } );
			    
			    var sphereGeometry = new THREE.SphereGeometry( r, 10, 10);
			    for ( var i = 0; i < sphereGeometry.faces.length; i++ ) 
			    {
			            UV = sphereGeometry.faceVertexUvs[0];
			            face = sphereGeometry.faces[ i ];  
			            // console.log("<" + face.normal.x + " " + face.normal.y + " " + face.normal.z+ ">");
			            face.color.setRGB( 0, 0, 0.8 * Math.random() + 0.2 );    
			            // face.color.setRGB( 0 , 0 , i/ sphereGeometry.faces.length );                
			    }
			    var sphere = new THREE.Mesh( sphereGeometry, faceColorMaterial );
			    sphere.position.set(x, y, z);
			    return sphere;
			}
			// Some useful parameters
			var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = 2/3 * window.innerHeight;
		    var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 1, FAR = 1000;

			// Renderer
			var renderer;
		    var container = document.createElement( 'div' );
		    document.body.appendChild( container );
		    if ( Detector.webgl )
		        renderer = new THREE.WebGLRenderer( {antialias:true} );
		    else
		        renderer = new THREE.CanvasRenderer(); 
		    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
		    // renderer.setClearColor();
		    container.appendChild(renderer.domElement);

		    // Create Scene, Camera, and Add Light
		    var scene = new THREE.Scene();
		    // var camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
		    var camera = new THREE.OrthographicCamera(SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, NEAR, FAR)
		    scene.add(camera);
		    camera.position.set(0,0,250);
		    var light = new THREE.PointLight(0xffffff);
		    light.position.set(0,250,0);
		    scene.add(light);

		    // Create the spheres
		    var spheres = new Array();
		    var sphere1 = makeSphereWithPosition(-1*SCREEN_WIDTH/3, SCREEN_HEIGHT/4, 0, SCREEN_HEIGHT/8);
		    spheres[0] = sphere1;
		    scene.add(sphere1);
		    var sphere2 = makeSphereWithPosition(0, SCREEN_HEIGHT/4, 0,SCREEN_HEIGHT/8);
		    spheres[1] = sphere2;
		    scene.add(sphere2);
		    var sphere3 = makeSphereWithPosition(1*SCREEN_WIDTH/3, SCREEN_HEIGHT/4, 0, SCREEN_HEIGHT/8);
		    spheres[2] = sphere3;
		    scene.add(sphere3);

		    // Get and Make the STL
			var parseStlBinary = function(stl) {
			var geo = new THREE.Geometry();
			var dv = new DataView(stl, 80); // 80 == unused header
			var isLittleEndian = true;
			var triangles = dv.getUint32(0, isLittleEndian); 

			// console.log('arraybuffer length:  ' + stl.byteLength);
			// console.log('number of triangles: ' + triangles);

			var offset = 4;
			for (var i = 0; i < triangles; i++) {
			    // Get the normal for this triangle
			    var normal = new THREE.Vector3(
			        dv.getFloat32(offset, isLittleEndian),
			        dv.getFloat32(offset+4, isLittleEndian),
			        dv.getFloat32(offset+8, isLittleEndian)
			    );
			    offset += 12;

			    // Get all 3 vertices for this triangle
			    for (var j = 0; j < 3; j++) {
			        geo.vertices.push(
			            new THREE.Vector3(
			                dv.getFloat32(offset, isLittleEndian),
			                dv.getFloat32(offset+4, isLittleEndian),
			                dv.getFloat32(offset+8, isLittleEndian)
			            )
			        );
			        offset += 12
			    }

			    // there's also a Uint16 "attribute byte count" that we
			    // don't need, it should always be zero.
			    offset += 2;   

			    // Create a new face for from the vertices and the normal             
			    geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));
			}

			// The binary STL I'm testing with seems to have all
			// zeroes for the normals, unlike its ASCII counterpart.
			// We can use three.js to compute the normals for us, though,
			// once we've assembled our geometry. This is a relatively 
			// expensive operation, but only needs to be done once.
			geo.computeFaceNormals();

			mesh = new THREE.Mesh( 
			    geo,
			    // new THREE.MeshNormalMaterial({
			    //     overdraw:true
			    // }
			    new THREE.MeshLambertMaterial({
			        overdraw:true,
			        color: 0xa8a8a8,
			        shading: THREE.FlatShading
			    }
			));
			scene.add(mesh);
			spheres[3] = mesh;
			mesh.scale.x = 2;
			mesh.scale.y = 2;
			mesh.position.set(0, -SCREEN_HEIGHT/4, 0);
			stl = null;
			};  


			var parseStl = function(stl) {
				var state = '';
				var lines = stl.split('\n');
				var geo = new THREE.Geometry();
				var name, parts, line, normal, done, vertices = [];
				var vCount = 0;
				stl = null;

				for (var len = lines.length, i = 0; i < len; i++) {
				    if (done) {
				        break;
				    }
				    line = lines[i].trim();
				    parts = line.split(' ');
				    switch (state) {
				        case '':
				            if (parts[0] !== 'solid') {
				                console.error(line);
				                console.error('Invalid state "' + parts[0] + '", should be "solid"');
				                return;
				            } else {
				                name = parts[1];
				                state = 'solid';
				            }
				            break;
				        case 'solid':
				            if (parts[0] !== 'facet' || parts[1] !== 'normal') {
				                console.error(line);
				                console.error('Invalid state "' + parts[0] + '", should be "facet normal"');
				                return;
				            } else {
				                normal = [
				                    parseFloat(parts[2]), 
				                    parseFloat(parts[3]), 
				                    parseFloat(parts[4])
				                ];
				                state = 'facet normal';
				            }
				            break;
				        case 'facet normal':
				            if (parts[0] !== 'outer' || parts[1] !== 'loop') {
				                console.error(line);
				                console.error('Invalid state "' + parts[0] + '", should be "outer loop"');
				                return;
				            } else {
				                state = 'vertex';
				            }
				            break;
				        case 'vertex': 
				            if (parts[0] === 'vertex') {
				                geo.vertices.push(new THREE.Vector3(
				                    parseFloat(parts[1]),
				                    parseFloat(parts[2]),
				                    parseFloat(parts[3])
				                ));
				            } else if (parts[0] === 'endloop') {
				                geo.faces.push( new THREE.Face3( vCount*3, vCount*3+1, vCount*3+2, new THREE.Vector3(normal[0], normal[1], normal[2]) ) );
				                vCount++;
				                state = 'endloop';
				            } else {
				                console.error(line);
				                console.error('Invalid state "' + parts[0] + '", should be "vertex" or "endloop"');
				                return;
				            }
				            break;
				        case 'endloop':
				            if (parts[0] !== 'endfacet') {
				                console.error(line);
				                console.error('Invalid state "' + parts[0] + '", should be "endfacet"');
				                return;
				            } else {
				                state = 'endfacet';
				            }
				            break;
				        case 'endfacet':
				            if (parts[0] === 'endsolid') {
				                //mesh = new THREE.Mesh( geo, new THREE.MeshNormalMaterial({overdraw:true}));
				                mesh = new THREE.Mesh( 
				                    geo, 
				                    new THREE.MeshLambertMaterial({
				                        overdraw:true,
				                        color: 0xa8a8a8,
				                        shading: THREE.FlatShading
				                    }
				                ));
				                scene.add(mesh);
				                done = true;
				            } else if (parts[0] === 'facet' && parts[1] === 'normal') {
				                normal = [
				                    parseFloat(parts[2]), 
				                    parseFloat(parts[3]), 
				                    parseFloat(parts[4])
				                ];
				                if (vCount % 1000 === 0) {
				                    console.log(normal);
				                }
				                state = 'facet normal';
				            } else {
				                console.error(line);
				                console.error('Invalid state "' + parts[0] + '", should be "endsolid" or "facet normal"');
				                return;
				            }
				            break;
				        default:
				            console.error('Invalid state "' + state + '"');
				            break;
				    }
				}
				scene.add(mesh);
				spheres[3] = mesh;
				mesh.scale.x = 4;
				mesh.scale.y = 4;
				mesh.position.set(0, -SCREEN_HEIGHT/4, 0);
			};



		    var xhr = new XMLHttpRequest();
			xhr.onreadystatechange = function () {
			    if ( xhr.readyState == 4 ) {
			        if ( xhr.status == 200 || xhr.status == 0 ) {
			            var rep = xhr.response; // || xhr.mozResponseArrayBuffer;
			            // console.log(rep);
			            // parseStlBinary(rep);
			            parseStl(xhr.responseText);
			            console.log('done parsing');
			        }
			    }
			}
			xhr.onerror = function(e) {
			    console.log(e);
			}
			// xhr.open( "GET", 'stls/Octocat-v1.stl', true );
			xhr.open( "GET", 'stls/wizzard.stl', true );
			// xhr.responseType = "arraybuffer";
			xhr.setRequestHeader("Accept","text/plain");
			xhr.setRequestHeader("Content-Type","text/plain");
			xhr.setRequestHeader('charset', 'x-user-defined');
			xhr.send( null );

		    // Do the rendering
		    function render() 
			{
			    renderer.render( scene, camera );
			}

			function animate() 
			{
				// console.log("Animate");
			    requestAnimationFrame( animate );
			    render();                
			    // update();
			}

			// Add Some listeners and Sphere Movement stuff
			var prevX, prevY;


			function moveSpheres(xDelta, yDelta) {
				console.log("<" + xDelta + "," +  yDelta + ">");
				for (var i = 0; i < spheres.length; i++) {
					var s = spheres[i];
					s.rotation.x += yDelta/ SCREEN_WIDTH;
					s.rotation.y += xDelta/ SCREEN_HEIGHT;
					console.log(s.rotation.x + " " + s.rotation.y)
				}
			}

			function mousedown(event) {
				// Only accept it if it is within 
				console.log("mousedown");
				renderer.domElement.addEventListener('mousemove', mousemove, false);
			}

			function mouseup(event) {
				console.log("mouseup");
				renderer.domElement.removeEventListener('mousemove', mousemove, false);
			}

			function mousemove(event) {
				// event.clientX, event.clientY
				if (!prevX && !prevY) {
					prevX = event.clientX;
					prevY = event.clientY;
				}
				xDelta = event.clientX - prevX;
				yDelta = event.clientY - prevY; 
				moveSpheres(xDelta, yDelta);
				prevX = event.clientX;
				prevY = event.clientY;
				console.log("mousemove");
			}


			renderer.domElement.addEventListener( 'mousedown', mousedown, false );
			renderer.domElement.addEventListener( 'mouseup', mouseup, false );

		    // animate it
		    animate();

		    // Test extra 


		</script>
	</body>
</html>